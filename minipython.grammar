/*
	Αλέξιος Μανδελιάς 3190106
	Δημήτριος Τσίρμπας 3190205
	Αναστάσιος Πασχαλίδης 3190166
*/

Package minipython;

Helpers
	digit = ['0' .. '9'];
	letter = ['a' .. 'z']|['A' .. 'Z']|'_'|'$';
	cr = 13;
	lf = 10;
	all = [0..127];
	eol = lf | cr | cr lf ;
	not_eol = [all - [cr + lf]];
	str_literal = [not_eol - '"'];
	str_literal_s = [not_eol - 39];

Tokens
	tab = 9;

	/* Comparison Operators */
	great_eq = '>=';
	less_eq = '<=';
	not_eq = '!=';
	eq = '==';
	sub_assign = '-=';
	div_assign = '/=';
	less_than = '<';
	greater_than = '>';

	/* Mathematical Operators */
	op_add = '+';
	op_sub = '-';
	op_exp = '**';
	op_mul = '*';
	op_div = '/';
	op_mod = '%';
	assign = '=';

	/* Other Symbols */
	l_par = '(';
	r_par = ')';
	l_br = '[';
	r_br = ']';
	comma =',';
	dot = '.';
	colon = ':';
	double_quote = '"';
	single_quote = 39;

	/* Keywords */
	true = 'true';
	false = 'false';
	def = 'def';
	if = 'if';
	for = 'for';
	in = 'in';
	while = 'while';
	print = 'print';
	return = 'return';
	assert = 'assert';
	length = 'len';
	max = 'max';
	min = 'min';
	import = 'import';
	as = 'as';
	from = 'from';
	logical_and = 'and';
	logical_or = 'or';
	logical_not = 'not';
	none = 'None';

	/* Other Tokens */
	eoltoken = eol;
	blank = (' ' | lf | cr);
	line_comment = '#' not_eol* eol;
	num = digit+ | (digit+ '.' digit+);
	id = letter (letter | digit)*;
	string_double_quotes = 34 str_literal* 34;
	string_single_quotes = 39 str_literal_s* 39;

Ignored Tokens
	blank, line_comment;

Productions
	/* Goal */
	goal = {commands} [com]:command [coms]:more_commands* {-> New goal([com coms.command])};
	command = 
		  {function} [func]:function {-> New command.function(func)}
		| {statement} [stmt]:statement {-> New command.statement(stmt)};
	more_commands {-> command} = {more_commands} eoltoken [com]:command {-> com};

	/* Function + Argument */
	function = {func_def} def [id]:identifier l_par [arg]:argument? r_par colon [stmt]:statement {-> New function(id, [arg], stmt) };
	argument = {argument} [id]:identifier [dv]:default_value? [arg_ls]:argument_list* {-> New argument(id, dv.value, [arg_ls])};
	default_value {-> value} = {default_value} assign [val]:value {-> New value.val(val)};
	argument_list {-> argument} = {argument_list} comma [id]:identifier [dv]:default_value? {-> New argument(id, dv.value)};

/*[*/
	/* Statement */
	statement =
		  {if} tab* if [cmp]:comparison colon [stmt]:statement {-> New statement.if(cmp, stmt)}
		| {while} tab* while [cmp]:comparison colon [stmt]:statement {-> New statement.while(cmp, stmt)}
		| {for} tab* for [id1]:identifier in [id2]:identifier colon [stmt]:statement {-> New statement.for(id1, id2, stmt)}
		| {return} tab* return [exp]:expression {-> New statement.return(exp.expr)}
		| {print} tab* print [exp]:expression [exp_ls]:expression_list* {-> New statement.print([exp.expr exp_ls.expr])}
		| {assign_var} tab* [id]:identifier [op_assign]:operate_assign [exp]:expression {-> New statement.assign_var(id, op_assign, exp.expr)}
		| {assign_lst} tab* [id]:identifier l_br [exp1]:expression r_br assign [exp2]:expression {-> New statement.assign_lst(id, exp1.expr, exp2.expr)}
		| {assertion} tab* assert [exp]:expression [exp_ls]:expression_list? {-> New statement.assertion([exp.expr exp_ls.expr])}
		| {func_call} tab* [fc]:function_call {-> New statement.func_call(fc)}
		/* Note that the Import Statement is NOT included in BNF as a Statement */
		/*  
		| {import_statement} tab* import_statement {-> import_statement.statement}
		*/
		| {empty_line} tab* {-> New statement.empty()};

	operate_assign =
		  {assign} assign {-> New operate_assign.assign()}
		| {sub_assign} sub_assign {-> New operate_assign.sub_assign()}
		| {div_assign} div_assign {-> New operate_assign.div_assign()};

	/* Expression */
		/* First the lowest priority (addition and subtraction) */
	expression {-> expr} =
		  {res2} [r2]:res2 {-> r2.expr}
		| {addition} [exp]:expression op_add [r2]:res2 {-> New expr.add(exp.expr, r2.expr)}
		| {subtraction} [exp]:expression op_sub [r2]:res2 {-> New expr.sub(exp.expr, r2.expr)};

		/* Then second lowest (multiplication, division and modulo) */
	res2 {-> expr} =
		  {res3} [r3]:res3 {-> r3.expr}
		| {multiplication} [r2]:res2 op_mul [r3]:res3 {-> New expr.mul(r2.expr, r3.expr)}
		| {division} [r2]:res2 op_div [r3]:res3 {-> New expr.div(r2.expr, r3.expr)}
		| {modulo} [r2]:res2 op_mod [r3]:res3 {-> New expr.mod(r2.expr, r3.expr)};

		/* Then the highest (exponentiation) */
	res3 {-> expr} =
		   {other_expr} [other]:other_expr {-> other.expr}
		| {exponentiation} [other]:other_expr op_exp [r3]:res3 {-> New expr.exp(other.expr, r3.expr)};

		/* Lastly, each of the above expressions can be one of the following */
	other_expr {-> expr} =
		  {id_bracket} [id]:identifier l_br [exp]:expression r_br {-> New expr.id_bracket(id, exp.expr)}
		| {func_call} [fc]:function_call {-> New expr.func_call(fc)}
		| {value} [val]:value {-> New expr.value(val)}
		| {id} [id]:identifier {-> New expr.id(id)}
		| {length_expr} length l_par [exp]:expression r_par {-> exp.expr}
		| {minimax} [minimax]:minimax l_par [val]:value [val_ls]:value_list* r_par {-> New expr.minimax(minimax, [val val_ls.value])}
		| {ls_def} l_br [exp]:expression [exp_ls]:expression_list* r_br {-> New expr.ls_def([exp.expr exp_ls.expr])};

	minimax =
		  {max} max {->New minimax.max()}
		| {min} min {-> New minimax.min()};
	value_list {-> value} = {value_list} comma [val]:value {-> val};

/*
	 Import 
	import_statement{->statement} =
		  {import_module} import module import_as? module_list* {-> New statement.import_module([module.identifier import_as.identifier module_list.identifier])}
		| {from_module_import} from module import identifier import_as? identifier_list* {-> New statement.from_import_statement(module, [identifier import_as.identifier identifier_list.identifier])};

	 Module 
	module {-> identifier*} = {module} id_dot* identifier {-> New identifier.identifier([id_dot.identifier identifier])};
	import_as {-> identifier} = {import_as} as identifier {-> New identifier(identifier)};
	module_list {-> identifier*} = {module_list} comma module import_as? {-> New identifier([identifier import_as])};

	id_dot {-> identifier} = {id_dot} identifier dot;
	identifier_list {-> identifier} = {identifier_list} comma identifier import_as? ;
*/


	/* Comparison */
		/* First the lowest priority (and, or) */
	comparison =
		  {negation} [neg]:negation {-> neg.comparison}
		| {and_comparison} [cmp]:comparison logical_and [neg]:negation {-> New comparison.and(cmp, neg.comparison)}
		| {or_comparison} [cmp]:comparison logical_or [neg]:negation {-> New comparison.or(cmp, neg.comparison)};

		/* Then the highest (not) */
	negation {-> comparison} =
		  {logical_value} [lv]:logical_value {-> lv.comparison}
		| {negation} logical_not [lv]:logical_value {-> New comparison.neg(lv.comparison)};

		/* Lastly, boolean literals and simple comparison expressions */
	logical_value {-> comparison} = 
		  {true} true {-> New comparison.true()} 
		| {false} false {-> New comparison.false()}
		| {expr_compare} [exp1]:expression [cmp_op]:comparison_operator [exp2]:expression {-> New comparison.single(exp1.expr, cmp_op, exp2.expr)};

	comparison_operator =
		  {gt} greater_than {-> New comparison_operator.gt()}
		| {lt} less_than {-> New comparison_operator.lt()}
		| {ge} great_eq {-> New comparison_operator.ge()}
		| {le} less_eq {-> New comparison_operator.le()}
		| {ne} not_eq {-> New comparison_operator.ne()}
		| {eq} eq {-> New comparison_operator.eq()};

	/* Function Call + Arglist */
	function_call = {func_call} [id]:identifier l_par [arg_ls]:arglist? r_par {-> New function_call(id, [arg_ls.expr])};
	arglist {-> expr*} = {arg_list} [exp]:expression [exp_ls]:expression_list* {-> [exp.expr exp_ls.expr]};

	/* Value */
	value =
		  {id_func} [id]:identifier dot [fc]:function_call {-> New value.id_func_call(id, fc)}
		| {number} [num]:number {-> num.value}
		| {str_double} [ssq]:string_double_quotes {-> New value.string1(ssq)}
		| {str_single} [sdq]:string_single_quotes {-> New value.string2(sdq)}
		| {none} none {-> New value.none()};

	/* Number + Identifier */
	number {-> value} = {num} [num]:num {-> New value.number(num)};
	identifier = {identifier} [id]:id {-> New identifier.id(id)};

	/* Leftover production that used at many places */
	expression_list {-> expr} = {expression_list} comma [exp]:expression {-> exp.expr};

/*#*/

Abstract Syntax Tree
	goal = command*;
	command = {function} function | {statement} statement;

	function = identifier argument* statement;
	argument = identifier value;

	statement = {if} comparison statement
		| {while} comparison statement
		| {for} [id1]:identifier [id2]:identifier statement
		| {return} expr
		| {print} expr*
		| {assign_var} identifier operate_assign expr
		| {assign_lst} identifier [ex1]:expr [ex2]:expr
		| {assertion} expr*
		| {func_call} function_call
		/* Note that the Import Statement is NOT included in BNF as a Statement */
		/* 
		| {import_module} moduleas*
		| {from_import_statement} module identifier_as*
		*/
		| {empty} ;

	operate_assign =  {assign} | {sub_assign} | {div_assign};

	expr =
		  {add} [exp1]:expr [exp2]:expr
		| {sub} [exp1]:expr [exp2]:expr
		| {mul} [exp1]:expr [exp2]:expr
		| {div} [exp1]:expr [exp2]:expr
		| {mod} [exp1]:expr [exp2]:expr
		| {exp} [base]:expr [power]:expr
		| {id_bracket} identifier expr
		| {value} value
		| {id} identifier
		| {minimax} minimax value*
		| {ls_def} expr*
		| {func_call} function_call;

	minimax = {min} | {max};
/*]*/

	/*
	module = {module} identifier*;
	moduleas = module identifier*;
	identifier_as = [id1]:identifier [id2]:identifier*;
	*/

	function_call = identifier expr*;

	value = {val} value
		| {number} num 
		| {none} 
		| {id_func_call} identifier function_call
		| {string1} string_double_quotes
		| {string2} string_single_quotes;

	
	identifier = {id} id;
	
	comparison_operator = {gt} | {lt} | {ge} | {le} | {ne} | {eq};
	
	comparison = {neg} comparison
		| {and} [cmp1]:comparison [cmp2]:comparison
		| {or} [cmp1]:comparison [cmp2]:comparison
		| {single} [exp1]:expr comparison_operator [exp2]:expr
		| {true}
		| {false};
